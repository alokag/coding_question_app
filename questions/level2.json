[
  {
    "title": "Balanced parentheses",
    "description": "Return true if brackets '()[]{}' are balanced.",
    "sample": "\"{[()]}\" -> true",
    "solution": "function isBalanced(s) {\n  const stack = [];\n  const map = {')':'(', ']':'[', '}':'{'};\n  for (const ch of s) {\n    if (ch === '(' || ch === '[' || ch === '{') stack.push(ch);\n    else if (map[ch]) {\n      if (stack.pop() !== map[ch]) return false;\n    }\n  }\n  return stack.length === 0;\n}\n"
  },
  {
    "title": "First and last position of target",
    "description": "Return [firstIndex,lastIndex] of target in sorted array or [-1,-1].",
    "sample": "[5,7,7,8,8,10], target=8 -> [3,4]",
    "solution": "function searchRange(nums, target) {\n  function findLeft() {\n    let l=0,r=nums.length-1,ans=-1;\n    while (l<=r) {\n      const m = Math.floor((l+r)/2);\n      if (nums[m]===target) { ans=m; r=m-1; }\n      else if (nums[m]<target) l=m+1;\n      else r=m-1;\n    }\n    return ans;\n  }\n  function findRight() {\n    let l=0,r=nums.length-1,ans=-1;\n    while (l<=r) {\n      const m = Math.floor((l+r)/2);\n      if (nums[m]===target) { ans=m; l=m+1; }\n      else if (nums[m]<target) l=m+1;\n      else r=m-1;\n    }\n    return ans;\n  }\n  return [findLeft(), findRight()];\n}\n"
  },
  {
    "title": "Sliding window - longest unique substring length",
    "description": "Return length of longest substring without repeating characters.",
    "sample": "\"abcabcbb\" -> 3",
    "solution": "function lengthOfLongestUnique(s) {\n  const set = new Set();\n  let l=0, res=0;\n  for (let r=0; r<s.length; r++) {\n    while (set.has(s[r])) { set.delete(s[l]); l++; }\n    set.add(s[r]);\n    res = Math.max(res, r-l+1);\n  }\n  return res;\n}\n"
  },
  {
    "title": "Merge intervals",
    "description": "Given intervals, merge overlapping ones.",
    "sample": "[[1,3],[2,6],[8,10]] -> [[1,6],[8,10]]",
    "solution": "function mergeIntervals(intervals) {\n  if (!intervals.length) return [];\n  intervals.sort((a,b)=>a[0]-b[0]);\n  const res = [intervals[0]];\n  for (let i=1;i<intervals.length;i++) {\n    const last = res[res.length-1];\n    if (intervals[i][0] <= last[1]) last[1] = Math.max(last[1], intervals[i][1]);\n    else res.push(intervals[i]);\n  }\n  return res;\n}\n"
  },
  {
    "title": "Detect cycle in linked list",
    "description": "Return true if linked list has a cycle (Floyd's algorithm).",
    "sample": "1->2->3->2 (cycle) -> true",
    "solution": "function hasCycle(head) {\n  let slow=head, fast=head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n"
  },
  {
    "title": "Inorder traversal of BST (iterative)",
    "description": "Return array of node values in inorder without recursion.",
    "sample": "BST -> [left, root, right]",
    "solution": "function inorder(root) {\n  const res = [];\n  const stack = [];\n  let node = root;\n  while (node || stack.length) {\n    while (node) { stack.push(node); node = node.left; }\n    node = stack.pop();\n    res.push(node.val);\n    node = node.right;\n  }\n  return res;\n}\n"
  },
  {
    "title": "Top K frequent elements",
    "description": "Return k most frequent elements in an array.",
    "sample": "[1,1,1,2,2,3], k=2 -> [1,2]",
    "solution": "function topKFrequent(nums, k) {\n  const map = {};\n  for (const n of nums) map[n]=(map[n]||0)+1;\n  const buckets = [];\n  for (const key in map) {\n    const freq = map[key];\n    buckets[freq] = buckets[freq] || [];\n    buckets[freq].push(Number(key));\n  }\n  const res = [];\n  for (let i = buckets.length -1; i>=0 && res.length<k; i--) {\n    if (buckets[i]) res.push(...buckets[i]);\n  }\n  return res.slice(0,k);\n}\n"
  },
  {
    "title": "Minimum in rotated sorted array",
    "description": "Find min value in rotated sorted array.",
    "sample": "[3,4,5,1,2] -> 1",
    "solution": "function findMin(nums) {\n  let l=0,r=nums.length-1;\n  while (l<r) {\n    const m = Math.floor((l+r)/2);\n    if (nums[m] > nums[r]) l = m+1;\n    else r = m;\n  }\n  return nums[l];\n}\n"
  },
  {
    "title": "Kth smallest in BST",
    "description": "Return kth smallest value using inorder traversal.",
    "sample": "BST, k=2 -> value",
    "solution": "function kthSmallest(root, k) {\n  const stack = [];\n  let node = root;\n  while (node || stack.length) {\n    while (node) { stack.push(node); node = node.left; }\n    node = stack.pop();\n    if (--k === 0) return node.val;\n    node = node.right;\n  }\n  return null;\n}\n"
  },
  {
    "title": "Group anagrams",
    "description": "Group words that are anagrams together.",
    "sample": "[\"eat\",\"tea\",\"tan\",\"ate\"] -> [[\"eat\",\"tea\",\"ate\"],[\"tan\"]]",
    "solution": "function groupAnagrams(strs) {\n  const map = {};\n  for (const s of strs) {\n    const key = s.split('').sort().join('');\n    map[key] = map[key] || [];\n    map[key].push(s);\n  }\n  return Object.values(map);\n}\n"
  },
  {
    "title": "Binary search for target",
    "description": "Return index of target in sorted array or -1.",
    "sample": "[1,2,3], target=2 -> 1",
    "solution": "function binarySearch(arr, target) {\n  let l=0, r=arr.length-1;\n  while (l<=r) {\n    const m = Math.floor((l+r)/2);\n    if (arr[m]===target) return m;\n    arr[m]<target ? l=m+1 : r=m-1;\n  }\n  return -1;\n}\n"
  },
  {
    "title": "Find peak element",
    "description": "Return index of any peak (element greater than neighbors).",
    "sample": "[1,2,3,1] -> 2",
    "solution": "function findPeak(arr) {\n  let l=0, r=arr.length-1;\n  while (l<r) {\n    const m = Math.floor((l+r)/2);\n    if (arr[m] < arr[m+1]) l = m+1;\n    else r = m;\n  }\n  return l;\n}\n"
  },
  {
    "title": "Product of array except self",
    "description": "Return array of products except self without division.",
    "sample": "[1,2,3,4] -> [24,12,8,6]",
    "solution": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const res = new Array(n).fill(1);\n  let prefix = 1;\n  for (let i=0;i<n;i++) { res[i]=prefix; prefix*=nums[i]; }\n  let suffix = 1;\n  for (let i=n-1;i>=0;i--) { res[i]*=suffix; suffix*=nums[i]; }\n  return res;\n}\n"
  },
  {
    "title": "Reverse words in a string",
    "description": "Reverse words order and trim extra spaces.",
    "sample": "\"  hello   world  \" -> \"world hello\"",
    "solution": "function reverseWords(s) {\n  const words = [];\n  let word = '';\n  for (let i=0;i<s.length;i++){\n    if (s[i] !== ' ') word += s[i];\n    else if (word) { words.push(word); word=''; }\n  }\n  if (word) words.push(word);\n  return words.reverse().join(' ');\n}\n"
  },
  {
    "title": "Rotate array k steps",
    "description": "Rotate array to the right by k steps in-place.",
    "sample": "[1,2,3,4,5], k=2 -> [4,5,1,2,3]",
    "solution": "function rotate(arr, k) {\n  k = k % arr.length;\n  reverse(arr, 0, arr.length-1);\n  reverse(arr, 0, k-1);\n  reverse(arr, k, arr.length-1);\n  function reverse(a,i,j){ while(i<j){[a[i],a[j]]=[a[j],a[i]]; i++; j--; } }\n}\n"
  },
  {
    "title": "Valid palindrome II (one deletion)",
    "description": "Return true if can be palindrome after deleting at most one char.",
    "sample": "\"abca\" -> true",
    "solution": "function validPalindrome(s) {\n  function isPal(l,r) { while(l<r){ if (s[l]!==s[r]) return false; l++; r--; } return true; }\n  let l=0,r=s.length-1;\n  while(l<r) {\n    if (s[l]!==s[r]) return isPal(l+1,r) || isPal(l,r-1);\n    l++; r--;\n  }\n  return true;\n}\n"
  },
  {
    "title": "Implement stack with min() in O(1)",
    "description": "Support push, pop, and min operations in O(1).",
    "sample": "",
    "solution": "class MinStack {\n  constructor(){ this.stack=[]; this.minStack=[]; }\n  push(x){ this.stack.push(x); if (!this.minStack.length || x<=this.minStack[this.minStack.length-1]) this.minStack.push(x); }\n  pop(){ const v=this.stack.pop(); if (v===this.minStack[this.minStack.length-1]) this.minStack.pop(); return v; }\n  min(){ return this.minStack[this.minStack.length-1]; }\n}\n"
  },
  {
    "title": "Longest common prefix",
    "description": "Find longest common prefix string amongst array of strings.",
    "sample": "['flower','flow','flight'] -> 'fl'",
    "solution": "function longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  let prefix = strs[0];\n  for (let s of strs) {\n    while (!s.startsWith(prefix)) prefix = prefix.slice(0, -1);\n    if (!prefix) return '';\n  }\n  return prefix;\n}\n"
  },
  {
    "title": "Validate Sudoku (partial)",
    "description": "Check whether a 9x9 board is valid so far.",
    "sample": "",
    "solution": "function isValidSudoku(board) {\n  const rows = Array.from({length:9},()=>new Set());\n  const cols = Array.from({length:9},()=>new Set());\n  const boxes = Array.from({length:9},()=>new Set());\n  for (let r=0;r<9;r++){\n    for (let c=0;c<9;c++){\n      const val = board[r][c];\n      if (val==='.') continue;\n      if (rows[r].has(val) || cols[c].has(val) || boxes[Math.floor(r/3)*3+Math.floor(c/3)].has(val)) return false;\n      rows[r].add(val); cols[c].add(val); boxes[Math.floor(r/3)*3+Math.floor(c/3)].add(val);\n    }\n  }\n  return true;\n}\n"
  },
  {
    "title": "Intersection of two arrays II",
    "description": "Return intersection including duplicates.",
    "sample": "[1,2,2,1] & [2,2] -> [2,2]",
    "solution": "function intersect(a,b) {\n  const map = {};\n  for (const x of a) map[x]=(map[x]||0)+1;\n  const res = [];\n  for (const x of b) {\n    if (map[x]) { res.push(x); map[x]--; }\n  }\n  return res;\n}\n"
  }
]